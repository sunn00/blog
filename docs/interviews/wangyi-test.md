---
title: "面试题--网易面试题"
date: 2022-06-18 22:03:00
sidebar: "auto"
categories:
  - 面试集锦
---

## HTML/CSS

### 三栏布局方式，两边固定中间自适应

https://juejin.cn/post/7110589748086833160



### CSS有哪些标签选择器

##### 通配符选择器

匹配页面中所有元素

用法：`*{ margin: 0; padding: 0; }`

##### id选择器

匹配相同id值的dom元素，只能对应文档中某一具体元素

用法：`#id名{ 属性1：属性值1；属性2：属性值2；}`

##### 类选择器

匹配相同class名的dom元素，多个dom可以使用同一个类名，可以实现为不同的dom指定相同的样式。同时，一个dom元素也可以应用多个class类，设置多个样式。

用法：`.类名{ 属性1：属性值1；属性2：属性值2；}`

##### 标签选择器

按标记名称分类，为页面中某一类标签指定统一的CSS样式。

用法：`标签名{ 属性1：属性值1；属性2：属性值2；}`

##### 兄弟选择器（+ 与 ~）

+表示相邻兄弟选择器，表示匹配紧跟第一个选择器并匹配第二个选择器的元素。如`p+a{ }`，匹配紧跟p元素后的一个a的元素。

用法：`选择器1 + 选择器2 { 属性1：属性值1；属性2：属性值2；}`



~表示查找某一个指定元素的后面的**所有**兄弟结点。

用法：`选择器1 ~ 选择器2 { 属性1：属性值1；属性2：属性值2；}`

##### 继承选择器

匹配两个标签器匹配dom的并集

用法：`选择器1 选择器2 { 属性1：属性值1；属性2：属性值2；}`

##### 任意选择器

匹配任意一个选择器的dom元素

用法：`选择器1, 选择器2 { 属性1：属性值1；属性2：属性值2；}`

##### 后代选择器

也称为包含选择器，用来选择特定的后代，表示匹配第二个选择器，且为第一个选择器的元素的后代。注意：只会查找儿子节点，不会查找其他被嵌套的标签。

用法：`标签名称1 > 标签名称2{ 属性1：属性值1；属性2：属性值2；}`

##### 属性选择器

属性选择器可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。

用法：`[标签名称] { 属性1：属性值1；属性2：属性值2；}`

CSS 选择器参考手册：

![image-20220618235257479](/Users/sunruonan/Typora_pic/image-20220618235257479.png)

##### 伪类选择器

| 伪类选择器     | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| :hover         | 定义标记在鼠标悬停(划过)时的样式                             |
| :link          | 定义标记在超链接状态下的样式                                 |
| :focus         | 定义标记在获取焦点时的样式                                   |
| :visited       | 定义标记被访问过后的样式                                     |
| :active        | 定义标记在选定时刻下的样式                                   |
| :checked       | 定义被选中的单选或多选框                                     |
| :disabled      | 定义不可触发元素的样式                                       |
| :first-child   | 定义同一个父元素下第一个标签的样式                           |
| :last-child    | 定义同一个父元素下最后一个标签的样式                         |
| :nth-child(n)  | 定义同一个父元素下第几个标签的样式                           |
| :not()         | 定义排除该标签后的其余元素                                   |
| :first-of-type | 直接选择父元素标签内**指定**标签的第一个元素                 |
| :has(选择器)   | 选择含有该选择器的某个父元素（实验中）                       |
| :is()          | 将选择器列表作为参数，并选择该列表中任意一个选择器可以选择的元素。 |
| :only-child    | 定义一个没有兄弟元素的dom元素，等同于`:first-child:last-child` |
| :invalid       | 定义一个没有通过校验的表单元素，例如from、input等元素        |
| :empty         | 定义没有任何后代元素的节点的样式                             |

##### :has()

```css
/* 匹配包含 <img> 子元素的 <a> 元素 */
a:has(img) { … }

/* 匹配包含<img>直接后代子元素的<a>元素 */
a:has(> img) { … }

/* 匹配不包含任何H元素的 <section> 元素：: */
section:not(:has(h1, h2, h3, h4, h5, h6))
```

##### :is()

```css
/* 选择header, main, footer里的任意一个悬浮状态的段落(p标签) */
:is(header, main, footer) p:hover {
  color: red;
  cursor: pointer;
}

/* 以上内容相当于以下内容 */
header p:hover,
main p:hover,
footer p:hover {
  color: red;
  cursor: pointer;
}
```



##### 伪对象选择器

伪对象选择器根据对象内部的局部元素定义其样式。

| 伪对象选择器  | 作用                                 |
| ------------- | ------------------------------------ |
| :first-letter | 定义文本的第一个字符样式             |
| :first-line   | 定义文本的首行样式                   |
| :before       | 定义对象之前内容的样式               |
| :after        | 定义对象之后内容的样式               |
| :first-child  | 定义同一个父元素下第一个标签的样式   |
| :last-child   | 定义同一个父元素下最后一个标签的样式 |
| :nth-child(n) | 定义同一个父元素下第几个标签的样式   |
| :not()        | 定义排除该标签后的其余元素           |

##### 深度选择器

当组件内的style有scoped时，就会给当前所有的标签添加一个【data-v-hash】的属性，并且在标签的css选择器的结尾加上和属性相同的的字段，这样起到的唯一性作用，实现类似于“作用域”的作用，使得当前组件内的样式只会作用于当前组件内的元素。

`>>>`：如果项目使用原生CSS，可以直接用`>>>`进行穿透

`/deep/`：如果项目中用到了预处理器 `sass less scss` 会因为无法编辑而报错 可以使用/deep/

`::v-deep`： 如果使用了预处理器都可以使用



### javascript中有哪些数据类型？各个数据类型是如何存储的？

##### 基本数据类型

string、number、boolean、symbol、bigint、**null、undefined**

##### 引用数据类型

object、function、array、date、regexp

##### 存储方式

基本数据类型的数据直接存储在栈中；引用数据类型存储在堆里，并在栈中存储保存数据的引用内存地址，以便快速查找到堆内存中的对象。

栈内存是自动分配内存的。而堆内存是动态分配内存的，不会自动释放。所以每次使用完对象的时候都要把它设置为 null，从而减少无用内存的消耗



### 判断数据类型的方法

##### typeof

只能判断出基础数据类型，如string、number、undefined、boolean、symbol，null和引用类型都会返回object

##### instanceof

判断对象是否在目标对象的原型链上，返回布尔值

##### Object.prototype.toString.call()

精准返回该类型的原始类型 `[object 类型]`，但不能细分为谁谁的实例，也不能判断字面量。

##### constractor



### 手写call、apply、bind

call 和 apply 实现思路主要是： 判断是否是函数调用，若非函数调用抛异常 通过新对象（context）来调用函数 给 context 创建一个 fn 设置为需要调用的函数 结束调用完之后删除 fn



bind 实现思路 判断是否是函数调用，若非函数调用抛异常 返回函数 判断函数的调用方式，是否是被 new 出来的 new 出来的话返回空对象，但是实例的__proto__指向_this 的prototype 完成函数柯里化



### 作用域和作用域链

作用域是规定了变量和函数可执行的范围；

每个函数都有一个作用域链，查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域的集合就是作用域链



### 闭包

函数执行时形成的私有执行上下文，使内部的私有变量不受外界干扰，起到保护和保存的作用。会出现内存泄露的问题。

##### 作用

保护；保存；避免命名冲突；解决循环绑定引发的索引问题；变量不会被销毁；在函数外可以使用函数内部的变量，使变量不会被垃圾回收机制回收

##### 应用

设计模式中的单例模式

for循环中保留i的操作

防抖和节流

函数柯里化

