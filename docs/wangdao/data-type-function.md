---
title: "数据类型 --  函数"
date: 2022-03-24 17:22:00
sidebar: "auto"
categories:
  - 基础三剑客
tags:
  - JavaScript
  - 数据类型
---

## 参数

### 参数的省略

函数参数不是必需的，js 允许省略参数。省略的参数的值就变为`undefined`。

但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`。

### 传递方式

若参数为基本类型，则为值传递，不会影响到外部数据；

若参数为复合类型，则为引用传递，除非整个替代，否则会影响到外部数据。

### 同名参数

如果有同名的参数，则取最后出现的那个值。

取值的时候，即使后面的`a`没有值或被省略，也是以其为准。

### \* arguments 对象

`arguments`对象包含了函数运行时的所有参数，他是一个类数组的对象。这个对象只有在函数体内部，才可以使用。

> 正常模式下，`arguments`对象可以在运行时修改。
>
> 严格模式下，`arguments`对象与函数参数不具有联动关系。

通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。

需要注意的是，数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。

如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。

下面是两种常用的转换方法：`slice`方法和逐一填入新数组。

```js
var args = Array.prototype.slice.call(arguments);

// 或者
var args = [];
for (var i = 0; i < arguments.length; i++) {
  args.push(arguments[i]);
}
```

## 函数的其他知识点

### \* 闭包

为了在函数外部读取函数内部声明的变量。

> 通过在函数的内部，再定义一个函数实现。

闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。

> 为什么闭包能够返回外层函数的内部变量？

原因是闭包（上例的`inc`）用到了外层变量（`start`），导致外层函数（`createIncrementor`）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。

### 立即自执行函数(IIFE)

为了避免解析的歧义，JavaScript 规定，如果`function`关键字出现在行首，一律解释成语句。因此，引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。

函数定义后立即调用的解决方法，**就是不要让`function`出现在行首**，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

> 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
