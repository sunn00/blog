(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{619:function(t,a,s){"use strict";s.r(a);var n=s(9),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数"}},[t._v("#")]),t._v(" 参数")]),t._v(" "),s("h3",{attrs:{id:"参数的省略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数的省略"}},[t._v("#")]),t._v(" 参数的省略")]),t._v(" "),s("p",[t._v("函数参数不是必需的，js 允许省略参数。省略的参数的值就变为"),s("code",[t._v("undefined")]),t._v("。")]),t._v(" "),s("p",[t._v("但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入"),s("code",[t._v("undefined")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"传递方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传递方式"}},[t._v("#")]),t._v(" 传递方式")]),t._v(" "),s("p",[t._v("若参数为基本类型，则为值传递，不会影响到外部数据；")]),t._v(" "),s("p",[t._v("若参数为复合类型，则为引用传递，除非整个替代，否则会影响到外部数据。")]),t._v(" "),s("h3",{attrs:{id:"同名参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同名参数"}},[t._v("#")]),t._v(" 同名参数")]),t._v(" "),s("p",[t._v("如果有同名的参数，则取最后出现的那个值。")]),t._v(" "),s("p",[t._v("取值的时候，即使后面的"),s("code",[t._v("a")]),t._v("没有值或被省略，也是以其为准。")]),t._v(" "),s("h3",{attrs:{id:"arguments-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arguments-对象"}},[t._v("#")]),t._v(" * arguments 对象")]),t._v(" "),s("p",[s("code",[t._v("arguments")]),t._v("对象包含了函数运行时的所有参数，他是一个类数组的对象。这个对象只有在函数体内部，才可以使用。")]),t._v(" "),s("blockquote",[s("p",[t._v("正常模式下，"),s("code",[t._v("arguments")]),t._v("对象可以在运行时修改。")]),t._v(" "),s("p",[t._v("严格模式下，"),s("code",[t._v("arguments")]),t._v("对象与函数参数不具有联动关系。")])]),t._v(" "),s("p",[t._v("通过"),s("code",[t._v("arguments")]),t._v("对象的"),s("code",[t._v("length")]),t._v("属性，可以判断函数调用时到底带几个参数。")]),t._v(" "),s("p",[t._v("需要注意的是，数组专有的方法（比如"),s("code",[t._v("slice")]),t._v("和"),s("code",[t._v("forEach")]),t._v("），不能在"),s("code",[t._v("arguments")]),t._v("对象上直接使用。")]),t._v(" "),s("p",[t._v("如果要让"),s("code",[t._v("arguments")]),t._v("对象使用数组方法，真正的解决方法是将"),s("code",[t._v("arguments")]),t._v("转为真正的数组。")]),t._v(" "),s("p",[t._v("下面是两种常用的转换方法："),s("code",[t._v("slice")]),t._v("方法和逐一填入新数组。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 或者")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" args "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arguments"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"函数的其他知识点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数的其他知识点"}},[t._v("#")]),t._v(" 函数的其他知识点")]),t._v(" "),s("h3",{attrs:{id:"闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" * 闭包")]),t._v(" "),s("p",[t._v("为了在函数外部读取函数内部声明的变量。")]),t._v(" "),s("blockquote",[s("p",[t._v("通过在函数的内部，再定义一个函数实现。")])]),t._v(" "),s("p",[t._v("闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。")]),t._v(" "),s("blockquote",[s("p",[t._v("为什么闭包能够返回外层函数的内部变量？")])]),t._v(" "),s("p",[t._v("原因是闭包（上例的"),s("code",[t._v("inc")]),t._v("）用到了外层变量（"),s("code",[t._v("start")]),t._v("），导致外层函数（"),s("code",[t._v("createIncrementor")]),t._v("）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。")]),t._v(" "),s("h3",{attrs:{id:"立即自执行函数-iife"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#立即自执行函数-iife"}},[t._v("#")]),t._v(" 立即自执行函数(IIFE)")]),t._v(" "),s("p",[t._v("为了避免解析的歧义，JavaScript 规定，如果"),s("code",[t._v("function")]),t._v("关键字出现在行首，一律解释成语句。因此，引擎看到行首是"),s("code",[t._v("function")]),t._v("关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。")]),t._v(" "),s("p",[t._v("函数定义后立即调用的解决方法，"),s("strong",[t._v("就是不要让"),s("code",[t._v("function")]),t._v("出现在行首")]),t._v("，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。")]),t._v(" "),s("blockquote",[s("p",[t._v("通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);